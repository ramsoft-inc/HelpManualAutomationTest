// Load environment variables from .env file
import { config } from 'dotenv';
config();

// Get API key from environment variable
const GEMINI_API_KEY = process.env.GEMINI_API_KEY;

// Validate that required environment variable is set
if (!GEMINI_API_KEY) {
    throw new Error("GEMINI_API_KEY environment variable is not set. Please check your .env file.");
}

// --------------------------------------------------------------------------------
// Polyfill CommonJS `require` so that ESM bundles (like the one generated by Rollup)
// can still use the occasional `require()` that sneaks in through external deps.
// This avoids the runtime error: "require is not defined in ES module scope".
// --------------------------------------------------------------------------------
import { createRequire } from 'module';
// Expose a global `require` compatible with the current file URL.
// (The cast to <any> keeps TypeScript/TS-aware linters quiet when they run.)
// eslint-disable-next-line @typescript-eslint/no-explicit-any
(globalThis).require = createRequire(import.meta.url);

// Import the preprocessing functions
import { generateInstructions, checkPythonDependencies } from './preprocess_instructions.js';

// Obsolete helper functions (`removeOverlays`, `clickDocumentViewerIcon`) have been removed
// since the application no longer shows blocking overlays or special viewer buttons.

// Accept --changed-files argument
const args = process.argv.slice(2);
let changedFiles = null;
let modeArg = null;
for (let i = 0; i < args.length; i++) {
    if (args[i] === '--changed-files' && args[i + 1]) {
        changedFiles = args[i + 1];
        i++;
    } else if ((args[i] === '--mode' || args[i] === '-m') && args[i + 1]) {
        modeArg = args[i + 1];
        i++;
    }
}

const getScenarioType = () => {
    if (modeArg) return modeArg;
    const modeIndex = args.findIndex(arg => arg === '--mode' || arg === '-m');
    if (modeIndex !== -1 && args[modeIndex + 1]) {
        const mode = args[modeIndex + 1];
        if (["ui_change", "new_feature", "default"].includes(mode)) {
            return mode;
        } else {
            console.warn(`‚ö†Ô∏è  Invalid mode: ${mode}. Using default mode.`);
        }
    }
    return "default";
};

const SCENARIO_TYPE = getScenarioType();

// Mode descriptions for better UX
const MODE_DESCRIPTIONS = {
    "ui_change": "UI Change Mode - Replace existing screenshots due to UI changes",
    "new_feature": "New Feature Mode - Take screenshots for new features/placeholders", 
    "default": "Default Mode - Standard translation mode with both English and Spanish docs"
};

(async () => {
    console.log('üöÄ Starting Enhanced Tracewright with Instruction Generation...\n');
    console.log(`üìã Mode: ${SCENARIO_TYPE} - ${MODE_DESCRIPTIONS[SCENARIO_TYPE]}\n`);
    
    // Step 1: Check Python dependencies
    const pythonDepsAvailable = await checkPythonDependencies();
    
    // Step 2: Generate instructions (with fallback if Python fails)
    let generatedInstructions;
    try {
        // Only pass --changed-files if changedFiles is set
        if (changedFiles) {
            generatedInstructions = await generateInstructions(SCENARIO_TYPE, changedFiles);
        } else {
            generatedInstructions = await generateInstructions(SCENARIO_TYPE, null);
        }
        console.log('üìã Generated Instructions:');
        console.log(generatedInstructions);
        console.log('\n' + '='.repeat(80) + '\n');
    } catch (error) {
        console.error('‚ö†Ô∏è  Instruction generation failed, using fallback instructions:', error.message);
        
        // Mode-specific fallback instructions
        const fallbackInstructions = {
            "ui_change": `
                - find the Pin place holder and enter the pin 145948
                - find the continue button and click on it
                - find any record in the worklist with a patient name and click on it
                - wait for any loading overlays or spinners to disappear completely
                - find the document viewer icon, which looks like a document or page icon, it may be in a circular wheel or toolbar, and click on it
                - take screenshots of any visible UI elements that need updating
                Done
            `,
            "new_feature": `
                - find the Pin place holder and enter the pin 145948
                - find the continue button and click on it
                - find any record in the worklist with a patient name and click on it
                - wait for any loading overlays or spinners to disappear completely
                - navigate to the new feature area
                - take screenshots of the new feature elements
                Done
            `,
            "default": `
                - find the Pin place holder and enter the pin 145948
                - find the continue button and click on it
                - find any record in the worklist with a patient name and click on it
                - wait for any loading overlays or spinners to disappear completely
                - find the document viewer icon, which looks like a document or page icon, it may be in a circular wheel or toolbar, and click on it
                Done
            `
        };
        
        generatedInstructions = fallbackInstructions[SCENARIO_TYPE] || fallbackInstructions["default"];
    }
    
    // Step 3: Initialize browser and tracewright
    console.log('üåê Launching browser...');
    
    // ----- Lazy-load Tracewright ---------------------------------------
    // 1. Try the compiled bundle (dist/esm/index.js).
    // 2. If it does not exist, build it on the fly (`npm run build` inside tracewrightt).
    // 3. If the build fails (or you are editing TypeScript and prefer zero-build),
    //    fall back to ts-node and import the .ts source directly.

    const { chromium, devices } = await import('playwright');
    const fs = await import('node:fs');
    const path = await import('node:path');
    const { fileURLToPath, pathToFileURL } = await import('node:url');
    const { execSync } = await import('node:child_process');

    const __dirname = path.dirname(fileURLToPath(import.meta.url));

    // The roll-up output structure can vary depending on preserveModules settings, so
    // we prepare a small helper that searches for the first plausible compiled entry.
    const esmDir = path.join(__dirname, 'tracewrightt', 'dist', 'esm');

    const findCompiledEntry = () => {
        const candidatePaths = [
            // New: direct path to the actual output location
            path.join(esmDir, 'tracewrightt', 'src', 'run.js'),
            path.join(esmDir, 'src', 'run.js'),
            path.join(esmDir, 'run.js'),
            path.join(esmDir, 'index.js'),
        ];
        return candidatePaths.find(p => fs.existsSync(p));
    };

    let compiledPath = findCompiledEntry();

    let tracewright;
    try {
        if (!compiledPath) {
            console.log('‚ÑπÔ∏è  Compiled Tracewright not found. Building locally...');
            execSync('npm run build', {
                cwd: path.join(__dirname, 'tracewrightt'),
                stdio: 'inherit',
            });

            // Re-evaluate compiledPath after the build
            compiledPath = findCompiledEntry();
        }

        if (!compiledPath) {
            throw new Error('Compiled bundle still not found after build');
        }

        // After (possible) build, import the bundle via file URL so that Node can
        // handle absolute Windows paths correctly.
        const twMod = await import(pathToFileURL(compiledPath).href);
        tracewright = twMod.default || twMod;
    } catch (buildErr) {
        console.warn('‚ö†Ô∏è  Could not import compiled bundle. Falling back to ts-node.', buildErr.message);
        // Register ts-node (transpile-only) so that we can import TypeScript sources
        // without an extra build step. For ESM we need to configure ts-node properly
        const { register } = await import('ts-node');
        register({
            esm: true,
            experimentalSpecifierResolution: 'node'
        });
        
        try {
            const twMod = await import('./tracewrightt/src/run.ts');
            tracewright = twMod.default || twMod;
        } catch (importErr) {
            console.error('‚ùå Failed to import TypeScript source:', importErr.message);
            throw new Error(`Cannot load Tracewright: ${importErr.message}`);
        }
    }
    
    const browser = await chromium.launch({
        headless: True,
        channel: 'chrome',
        args: [
            "--disable-notifications",
            "--use-fake-ui-for-media-stream",
            "--disable-features=PermissionChip,PermissionPrompt",
            "--disable-gpu",
            "--font-render-hinting=none",
            "--disable-web-security",
            "--disable-site-isolation-trials",
            "--remote-debugging-port=9222",
            "--window-size=1280,800"
        ]
    });
    
    // Create browser context with better error handling
    const context = await browser.newContext({
        ...devices['Desktop Chrome'],
        ignoreHTTPSErrors: true,
        viewport: { width: 1280, height: 800 },
        screen: { width: 1280, height: 800 },
        // geolocation: { latitude: 37.7749, longitude: -122.4194 },
        timeout: 200000,
    });
    
    // Grant permissions to prevent prompts
    await context.grantPermissions([
        'geolocation',
        'notifications',
        'camera',
        'microphone'
    ], { origin: 'https://team-meta-apim.azure-api.net' });

    const page = await context.newPage();
    
    // Set default timeout to 2 minutes for all page actions
    page.setDefaultTimeout(120000);

    try {
        // Step 4: Navigate to the website
        console.log('üîó Opening website...');
        await page.goto('https://team-meta-apim.azure-api.net/', { timeout: 6000000 });
        
        // Wait for page to fully load and settle
        console.log('‚è≥ Waiting for page to load and settle...');
        await page.waitForLoadState('networkidle', { timeout: 30000 });
        await page.waitForLoadState('domcontentloaded', { timeout: 30000 });
        
        // Additional wait to ensure all dynamic content is loaded
        await page.waitForTimeout(2000);
        
        console.log('‚úÖ Page loaded and settled');

        // Step 4.5: Perform manual login
        console.log('üìß Performing manual login...');
        // await page.getByPlaceholder('Enter your email address here').fill('ramsoftlocaluser02@gmail.com', { timeout: 60000 });
        await page.getByPlaceholder('Enter your email address here').fill('ramsoftlocalteamprime@gmail.com', { timeout: 60000 });
        await page.getByRole('button', { name: 'Continue' }).click({ timeout: 60000 });
        
        // Wait for email submission to complete
        await page.waitForLoadState('networkidle', { timeout: 30000 });
        
        await page.getByLabel('Password').fill('225588', { timeout: 60000 });
        await page.getByRole('button', { name: 'Continue' }).click({ timeout: 60000 });
        
        // Wait for login to complete and main application to load
        console.log('‚è≥ Waiting for login to complete and application to load...');
        await page.waitForLoadState('networkidle', { timeout: 60000 });
        await page.waitForLoadState('domcontentloaded', { timeout: 60000 });
        
        // Additional wait to ensure the main application UI is fully rendered
        await page.waitForTimeout(3000);
        
        console.log('‚úÖ Login completed and application loaded');

        // await page.locator('[data-testid="documentviewer-icon"]').first().click({ force: true, timeout: 60000 });
    //     await page.getByTestId('Avatar Team Prime, Ramsoft Local').click({ timeout: 60000 });
    //     await page.getByRole('button', { name: 'USER SETTINGS' }).click({ timeout: 60000 });
    //     await page.getByTestId('LanguageIcon').click({ timeout: 60000 });
    //     // await page.getByRole('button', { name: 'English' }).click({ timeout: 60000 });
    //     // await page.locator('[role="button"][aria-haspopup="listbox"]').click({ timeout: 60000 });
    //     await page.getByRole('button', { name: 'English' })
    // .or(page.getByRole('button', { name: 'Espa√±ol' }))
    // .click({ timeout: 60000 });
    //     const espanolElements = page.getByText('Espa√±ol');
    //     const count = await espanolElements.count();
        
    //     if (count === 1) {
    //         await espanolElements.click({ timeout: 60000 });
    //         console.log('Clicked on Espa√±ol');
    //     } else if (count > 1) {
    //         console.log('Multiple Espa√±ol elements found, skipping step');
    //     } else {
    //         console.log('No Espa√±ol element found, skipping step');
    //     }
    //     // Use the function before clicking the SVG element
    //     try {
    //         console.log('üîÑ Removing overlays before clicking SVG...');
    //         await removeOverlays(page);
    //         await page.waitForTimeout(500); // Wait a bit to ensure overlays are gone
    //         await page.locator('svg:has(path[d*="m12 5.69 5 4.5V18"])').click({ timeout: 60000, force: true });
    //         console.log('‚úÖ SVG clicked successfully');
    //     } catch (error) {
    //         console.error('‚ùå Error clicking SVG:', error);
    //     }

        // Step 5: Run Tracewright with generated instructions
        console.log('ü§ñ Running Tracewright with generated instructions...');
        try {
            await tracewright(page, {
                script: generatedInstructions
            });
            
            // No additional manual fallbacks required
        } catch (tracewrightError) {
            console.log('‚ö†Ô∏è  Tracewright failed, trying enhanced manual approach...');
            console.error('Tracewright error details:', tracewrightError);
            
            // Manual overlay / viewer workaround removed (no longer necessary)
        }
 
        console.log('‚úÖ Automation execution completed successfully!');
        
        // Optional: Keep browser open for inspection
        console.log('üîç Browser will remain open for inspection. Close manually when done.');
        
    } catch (error) {
        console.error('‚ùå Error during execution:', error);
        console.log('üîç Browser will remain open for debugging. Close manually when done.');
    }
    
    // Uncomment to auto-close browser
    // await browser.close();
})(); 